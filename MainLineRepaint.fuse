--[[ 
MainLineRepaint.fuse
Author: akahito_ot
License: MIT
Version: 1.1
Description:
    Repaints main line pixels (specified color) by replacing them
    with neighboring non-main-line pixels through horizontal and vertical scanning passes
    for DaVinci Resolve / Fusion.
    Ported from F's Plugins MainLineRepaint by bry-ful [Hiroshi Furuhashi].
    https://github.com/bryful/F-s-PluginsProjects/tree/master/MainLineRepaint

]]

FuRegisterClass("MainLineRepaint", CT_Tool, {
    REGS_Category = "F'sPlugins",
    REGS_OpIconString = "MLR",
    REGS_OpDescription = "Main Line Repaint",
    REG_NoMotionBlurCtrls = true,
})

FSMLR_Params = [[
    float mainColor[3];    // RGB values of the color to be repainted
    float tolerance;       // Color matching tolerance (0.0-1.0)
    int scanLength;        // Maximum distance to scan for replacement pixels
    int srcsize[2];        // Image dimensions [width, height]
]]

FSMLR_HorizontalPassSource = [[
// Pixel classification states
#define PS_NORMAL 0  // Normal pixel (not main color, not transparent)
#define PS_TRANS 1   // Transparent pixel (alpha < 0.01)
#define PS_MAIN 2    // Main line pixel (matches target color within tolerance)

// Calculate luminance using Rec. 709 coefficients
__DEVICE__ float getLum(float4 color) {
    float r = _clampf(color.x, 0.0f, 1.0f);
    float g = _clampf(color.y, 0.0f, 1.0f);
    float b = _clampf(color.z, 0.0f, 1.0f);
    return (0.29891f * r + 0.58661f * g + 0.11448f * b);
}

// Classify pixel from pixel value
__DEVICE__ int classifyFromPixel(float4 pixel, float3 mainColor, float thresh) {
    // Check transparency first
    if (pixel.w < 0.01f) return PS_TRANS;
    
    // Check if pixel matches main color within tolerance
    float dr = _fabs(pixel.x - mainColor.x);
    float dg = _fabs(pixel.y - mainColor.y);
    float db = _fabs(pixel.z - mainColor.z);
    float maxDiff = _fmaxf(_fmaxf(dr, dg), db);
    
    if (maxDiff <= thresh) return PS_MAIN;
    return PS_NORMAL;
}

// Classify pixel from coordinates
__DEVICE__ int classifyFromCoord(__TEXTURE2D__ src, int x, int y, float3 mainColor, float thresh) {
    float4 pixel = _tex2DVec4(src, x, y);
    return classifyFromPixel(pixel, mainColor, thresh);
}

__KERNEL__ void FSMLR_HorizontalPassKernel(__CONSTANTREF__ FSMLR_Params *params,
    __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y)
    
    // Boundary check
    if (x >= params->srcsize[0] || y >= params->srcsize[1]) return;
    
    float3 mainColor = to_float3(params->mainColor[0], params->mainColor[1], params->mainColor[2]);
    
    float4 current = _tex2DVec4(src, x, y);
    
    int currentStatus = classifyFromPixel(current, mainColor, params->tolerance);
    
    // If not a main line pixel, pass through unchanged
    if (currentStatus != PS_MAIN) {
        _tex2DVec4Write(dst, x, y, current);
        return;
    }
    
    // Handle left edge: use right neighbor if it's not main color
    if (x == 0) {
        int rightStatus = classifyFromCoord(src, 1, y, mainColor, params->tolerance);
        if (rightStatus != PS_MAIN) {
            _tex2DVec4Write(dst, x, y, _tex2DVec4(src, 1, y));
        } else {
            _tex2DVec4Write(dst, x, y, current);
        }
        return;
    }
    
    // Handle right edge: use left neighbor if it's not main color
    if (x == params->srcsize[0] - 1) {
        int leftStatus = classifyFromCoord(src, x - 1, y, mainColor, params->tolerance);
        if (leftStatus != PS_MAIN) {
            _tex2DVec4Write(dst, x, y, _tex2DVec4(src, x - 1, y));
        } else {
            _tex2DVec4Write(dst, x, y, current);
        }
        return;
    }

    // Scan for non-main-line pixels on both sides
    int leftStatus = PS_MAIN;
    int rightStatus = PS_MAIN;
    float4 leftPixel = current;
    float4 rightPixel = current;
    
    // Scan left for nearest non-main-line pixel
    for (int k = 1; k < params->scanLength; k++) {
        int x2 = x - k;
        if (x2 < 0) break;
        
        float4 pixel = _tex2DVec4(src, x2, y);
        int status = classifyFromPixel(pixel, mainColor, params->tolerance);
        if (status != PS_MAIN) {
            leftPixel = pixel;
            leftStatus = status;
            break;
        }
    }
    
    // Scan right for nearest non-main-line pixel
    for (int k = 1; k < params->scanLength; k++) {
        int x2 = x + k;
        if (x2 >= params->srcsize[0]) break;
        
        float4 pixel = _tex2DVec4(src, x2, y);
        int status = classifyFromPixel(pixel, mainColor, params->tolerance);
        if (status != PS_MAIN) {
            rightPixel = pixel;
            rightStatus = status;
            break;
        }
    }
    
    // Determine replacement color based on surrounding pixel pattern
    float4 result = current;
    int hPattern = (leftStatus << 8) | rightStatus;  // Encode pattern as 16-bit value
    
    // Both sides are normal: choose darker pixel
    if (hPattern == ((PS_NORMAL << 8) | PS_NORMAL)) {
        float leftLum = getLum(leftPixel);
        float rightLum = getLum(rightPixel);
        result = (leftLum <= rightLum) ? leftPixel : rightPixel;
    }
    // Left is main, right is normal: use right
    else if (hPattern == ((PS_MAIN << 8) | PS_NORMAL)) result = rightPixel;
    // Left is normal, right is main: use left
    else if (hPattern == ((PS_NORMAL << 8) | PS_MAIN)) result = leftPixel;
    // Left is transparent, right is normal: use right
    else if (hPattern == ((PS_TRANS << 8) | PS_NORMAL)) result = rightPixel;
    // Left is normal, right is transparent: use left
    else if (hPattern == ((PS_NORMAL << 8) | PS_TRANS)) result = leftPixel;
    // Both sides are transparent: make pixel transparent
    else if (hPattern == ((PS_TRANS << 8) | PS_TRANS)) result = to_float4(0.0f, 0.0f, 0.0f, 0.0f);
    
    _tex2DVec4Write(dst, x, y, result);
}
]]

FSMLR_VerticalPassSource = [[
// Pixel classification states (same as horizontal pass)
#define PS_NORMAL 0  // Normal pixel (not main color, not transparent)
#define PS_TRANS 1   // Transparent pixel (alpha < 0.01)
#define PS_MAIN 2    // Main line pixel (matches target color within tolerance)

// Calculate luminance using Rec. 709 coefficients
__DEVICE__ float getLum(float4 color) {
    float r = _clampf(color.x, 0.0f, 1.0f);
    float g = _clampf(color.y, 0.0f, 1.0f);
    float b = _clampf(color.z, 0.0f, 1.0f);
    return (0.29891f * r + 0.58661f * g + 0.11448f * b);
}

// Classify pixel from pixel value
__DEVICE__ int classifyFromPixel(float4 pixel, float3 mainColor, float thresh) {
    // Check transparency first
    if (pixel.w < 0.01f) return PS_TRANS;
    
    // Check if pixel matches main color within tolerance
    float dr = _fabs(pixel.x - mainColor.x);
    float dg = _fabs(pixel.y - mainColor.y);
    float db = _fabs(pixel.z - mainColor.z);
    float maxDiff = _fmaxf(_fmaxf(dr, dg), db);
    
    if (maxDiff <= thresh) return PS_MAIN;
    return PS_NORMAL;
}

// Classify pixel from coordinates
__DEVICE__ int classifyFromCoord(__TEXTURE2D__ src, int x, int y, float3 mainColor, float thresh) {
    float4 pixel = _tex2DVec4(src, x, y);
    return classifyFromPixel(pixel, mainColor, thresh);
}

__KERNEL__ void FSMLR_VerticalPassKernel(__CONSTANTREF__ FSMLR_Params *params,
    __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y)
    
    // Boundary check
    if (x >= params->srcsize[0] || y >= params->srcsize[1]) return;
    
    float3 mainColor = to_float3(params->mainColor[0], params->mainColor[1], params->mainColor[2]);
    
    float4 current = _tex2DVec4(src, x, y);
    
    int currentStatus = classifyFromPixel(current, mainColor, params->tolerance);
    
    // If not a main line pixel, pass through unchanged
    if (currentStatus != PS_MAIN) {
        _tex2DVec4Write(dst, x, y, current);
        return;
    }

    // Handle top edge: use bottom neighbor if it's not main color
    if (y == 0) {
        int bottomStatus = classifyFromCoord(src, x, 1, mainColor, params->tolerance);
        if (bottomStatus != PS_MAIN) {
            _tex2DVec4Write(dst, x, y, _tex2DVec4(src, x, 1));
        } else {
            _tex2DVec4Write(dst, x, y, current);
        }
        return;
    }
    
    // Handle bottom edge: use top neighbor if it's not main color
    if (y == params->srcsize[1] - 1) {
        int topStatus = classifyFromCoord(src, x, y - 1, mainColor, params->tolerance);
        if (topStatus != PS_MAIN) {
            _tex2DVec4Write(dst, x, y, _tex2DVec4(src, x, y - 1));
        } else {
            _tex2DVec4Write(dst, x, y, current);
        }
        return;
    }
    
    // Scan for non-main-line pixels above and below
    int topStatus = PS_MAIN;
    int bottomStatus = PS_MAIN;
    float4 topPixel = current;
    float4 bottomPixel = current;
    
    // Scan upward for nearest non-main-line pixel
    for (int k = 1; k < params->scanLength; k++) {
        int y2 = y - k;
        if (y2 < 0) break;
        
        float4 pixel = _tex2DVec4(src, x, y2);
        int status = classifyFromPixel(pixel, mainColor, params->tolerance);
        if (status != PS_MAIN) {
            topPixel = pixel;
            topStatus = status;
            break;
        }
    }
    
    // Scan downward for nearest non-main-line pixel
    for (int k = 1; k < params->scanLength; k++) {
        int y2 = y + k;
        if (y2 >= params->srcsize[1]) break;
        
        float4 pixel = _tex2DVec4(src, x, y2);
        int status = classifyFromPixel(pixel, mainColor, params->tolerance);
        if (status != PS_MAIN) {
            bottomPixel = pixel;
            bottomStatus = status;
            break;
        }
    }
    
    // Determine replacement color based on surrounding pixel pattern
    float4 result = current;
    int vPattern = (topStatus << 8) | bottomStatus;  // Encode pattern as 16-bit value
    
    // Both sides are normal: choose darker pixel
    if (vPattern == ((PS_NORMAL << 8) | PS_NORMAL)) {
        float topLum = getLum(topPixel);
        float bottomLum = getLum(bottomPixel);
        result = (topLum <= bottomLum) ? topPixel : bottomPixel;
    }
    // Top is main, bottom is normal: use bottom
    else if (vPattern == ((PS_MAIN << 8) | PS_NORMAL)) result = bottomPixel;
    // Top is normal, bottom is main: use top
    else if (vPattern == ((PS_NORMAL << 8) | PS_MAIN)) result = topPixel;
    // Top is transparent, bottom is normal: use bottom
    else if (vPattern == ((PS_TRANS << 8) | PS_NORMAL)) result = bottomPixel;
    // Top is normal, bottom is transparent: use top
    else if (vPattern == ((PS_NORMAL << 8) | PS_TRANS)) result = topPixel;
    // Both sides are transparent: make pixel transparent
    else if (vPattern == ((PS_TRANS << 8) | PS_TRANS)) result = to_float4(0.0f, 0.0f, 0.0f, 0.0f);
    
    _tex2DVec4Write(dst, x, y, result);
}
]]

-- Create UI controls for the tool
function Create()
    -- Main input image
    InImage = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })
    
    -- Main color RGB controls (grouped as a color picker)
    InMainR = self:AddInput("Main Color", "MainColor", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.0,
        INP_MinScale = 0.0,
        INP_MaxScale = 1.0,
        IC_ControlGroup = 2, 
        IC_ControlID = 0,
    })
    
    InMainG = self:AddInput("Main Color G", "MainColorG", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.0,
        INP_MinScale = 0.0,
        INP_MaxScale = 1.0,
        IC_ControlGroup = 2, 
        IC_ControlID = 1,
    })
    
    InMainB = self:AddInput("Main Color B", "MainColorB", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.0,
        INP_MinScale = 0.0,
        INP_MaxScale = 1.0,
        IC_ControlGroup = 2, 
        IC_ControlID = 2,
    })
    
    -- Color matching tolerance (displayed as percentage)
    InTolerance = self:AddInput("Tolerance (%)", "Tolerance", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.1,
        INP_MinScale = 0,
        INP_MaxScale = 20,
    })
    
    -- Maximum scanning distance in pixels
    InScanLength = self:AddInput("Scan Length", "ScanLength", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 2,
        INP_Integer = true,
        INP_MinScale = 2,
        INP_MaxScale = 50,
    })
    
    -- Output image
    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })
end

-- Compare images by sampling 100-400 grid points for early iteration exit
function CompareImage(img1, img2)
    if not img1 or not img2 then return false end
    if img1.Width ~= img2.Width or img1.Height ~= img2.Height then return false end
    
    -- Create Pixel objects for comparison
    local p1 = Pixel()
    local p2 = Pixel()
    
    -- Calculate sampling step to check approximately 10x10 to 20x20 grid
    local samplesX = math.min(20, math.max(10, math.floor(img1.Width / 50)))
    local samplesY = math.min(20, math.max(10, math.floor(img1.Height / 50)))
    local stepX = math.floor(img1.Width / samplesX)
    local stepY = math.floor(img1.Height / samplesY)
    
    -- Sample pixels in a grid pattern
    for y = 0, img1.Height - 1, stepY do
        for x = 0, img1.Width - 1, stepX do
            img1:GetPixel(x, y, p1)
            img2:GetPixel(x, y, p2)
            
            -- Compare RGBA values with small epsilon for floating point
            if math.abs(p1.R - p2.R) > 0.0001 or 
               math.abs(p1.G - p2.G) > 0.0001 or 
               math.abs(p1.B - p2.B) > 0.0001 or 
               math.abs(p1.A - p2.A) > 0.0001 then
                return false
            end
        end
    end
    
    return true
end

-- Main processing function
function Process(req)
    -- Get input values
    local img = InImage:GetValue(req)
    local mainR = InMainR:GetValue(req).Value
    local mainG = InMainG:GetValue(req).Value
    local mainB = InMainB:GetValue(req).Value
    local tolerance = InTolerance:GetValue(req).Value / 100.0
    local scanLength = InScanLength:GetValue(req).Value
    
    -- Early exit if no input image
    if not img then
        OutImage:Set(req, nil)
        return
    end
    
    local width = img.Width
    local height = img.Height
    
    -- Allocate two buffers for ping-pong processing
    local bufferA = Image({IMG_Like = img})
    local bufferB = Image({IMG_Like = img})
    
    -- Iterate multiple times for better coverage of larger main-line areas
    local scanCount = 10
    local currentImg = img
    local prevImg = nil
    
    for iteration = 1, scanCount do
        -- Alternate buffers: odd iterations use A->B, even iterations use B->A
        local tempImg, outImg
        if iteration % 2 == 1 then
            tempImg = bufferA
            outImg = bufferB
        else
            tempImg = bufferB
            outImg = bufferA
        end
        
        -- === Horizontal Pass ===
        local node1 = DVIPComputeNode(req, "FSMLR_HorizontalPassKernel", FSMLR_HorizontalPassSource, 
                                    "FSMLR_Params", FSMLR_Params)
        
        if not node1 then
            print("MainLineRepaint: Failed to create horizontal pass node")
            OutImage:Set(req, img)
            return
        end
        
        -- Set parameters for horizontal pass
        local params = node1:GetParamBlock(FSMLR_Params)
        params.mainColor[0] = mainR
        params.mainColor[1] = mainG
        params.mainColor[2] = mainB
        params.tolerance = tolerance
        params.scanLength = scanLength
        params.srcsize[0] = width
        params.srcsize[1] = height
        node1:SetParamBlock(params)
        
        -- Configure texture sampling (point filtering, no interpolation)
        node1:AddSampler("RowSampler", TEX_FILTER_MODE_POINT, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_FALSE)
        node1:AddInput("src", currentImg)
        node1:AddOutput("dst", tempImg)
        
        -- Execute horizontal pass
        local success = node1:RunSession(req)
        if not success then
            print("MainLineRepaint: Horizontal pass failed at iteration " .. iteration)
            OutImage:Set(req, img)
            return
        end
        
        -- === Vertical Pass ===
        local node2 = DVIPComputeNode(req, "FSMLR_VerticalPassKernel", FSMLR_VerticalPassSource, 
                                    "FSMLR_Params", FSMLR_Params)
        
        if not node2 then
            print("MainLineRepaint: Failed to create vertical pass node")
            OutImage:Set(req, img)
            return
        end
        
        -- Set parameters for vertical pass
        local params2 = node2:GetParamBlock(FSMLR_Params)
        params2.mainColor[0] = mainR
        params2.mainColor[1] = mainG
        params2.mainColor[2] = mainB
        params2.tolerance = tolerance
        params2.scanLength = scanLength
        params2.srcsize[0] = width
        params2.srcsize[1] = height
        node2:SetParamBlock(params2)
        
        -- Configure texture sampling (point filtering, no interpolation)
        node2:AddSampler("RowSampler", TEX_FILTER_MODE_POINT, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_FALSE)
        node2:AddInput("src", tempImg)
        node2:AddOutput("dst", outImg)
        
        -- Execute vertical pass and check for convergence
        local success2 = node2:RunSession(req)
        if not success2 then
            print("MainLineRepaint: Vertical pass failed at iteration " .. iteration)
            OutImage:Set(req, img)
            return
        end
        
        -- Early exit check: compare with previous iteration (skip first iteration)
        if iteration > 1 and prevImg and CompareImage(outImg, prevImg) then
            currentImg = outImg
            break  -- No change detected, iteration complete
        end
        
        prevImg = currentImg
        currentImg = outImg
    end

    -- Output the final processed image
    OutImage:Set(req, currentImg)
end