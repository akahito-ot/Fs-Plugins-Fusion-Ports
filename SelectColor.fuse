--[[ 
SelectColor.fuse
Author: akahito_ot
License: MIT
Version: 1.1
Description:
    Display only pixels matching selected colors (up to 8 colors).
    Ideal for color-based masking and selection in animation workflows.
    Ported from F's Plugins SelectColor by bry-ful [Hiroshi Furuhashi].
    https://github.com/bryful/F-s-PluginsProjects/tree/master/SelectColor
]]

FuRegisterClass("SelectColor", CT_Tool, {
    REGS_Category = "F'sPlugins",
    REGS_OpIconString = "SCL",
    REGS_OpDescription = "Selected Color Mask - Show only selected colors",
    REG_NoMotionBlurCtrls = true,
})

-- Parameter structure for GPU kernels
FSSCL_Params = [[
    float targetColors[8][3];  // Up to 8 RGB colors to match
    int numColors;              // Number of active colors
    float tolerance;            // Color matching tolerance (Euclidean distance)
    int srcsize[2];             // Image dimensions [width, height]
    int expandRadius;           // Pixel expansion radius
    int invert;                 // Invert mask (0=normal, 1=inverted)
]]

-- Mask generation kernel
FSSCL_MaskGeneratorSource = [[
// Check if pixel matches any target color within tolerance
__DEVICE__ bool isTargetColor(float4 pixel, __CONSTANTREF__ FSSCL_Params *params) {
    // Skip transparent pixels
    if (pixel.w < 0.999f) return false;
    
    // Check against all target colors
    for (int c = 0; c < params->numColors; c++) {
        float dr = pixel.x - params->targetColors[c][0];
        float dg = pixel.y - params->targetColors[c][1];
        float db = pixel.z - params->targetColors[c][2];
        
        // Euclidean distance in RGB space
        float dist = _sqrtf(dr*dr + dg*dg + db*db);
        if (dist < params->tolerance) return true;
    }
    return false;
}

__KERNEL__ void FSSCL_MaskGeneratorKernel(__CONSTANTREF__ FSSCL_Params *params,
    __TEXTURE2D__ src, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y)
    
    // Boundary check
    if (x >= params->srcsize[0] || y >= params->srcsize[1]) return;
    
    float4 pixel = _tex2DVec4(src, x, y);
    
    bool isTarget = isTargetColor(pixel, params);
    
    // Apply invert if enabled
    if (params->invert == 1) {
        isTarget = !isTarget;
    }
    
    // Output: keep pixel if target, otherwise transparent
    if (isTarget) {
        _tex2DVec4Write(dst, x, y, pixel);
    } else {
        _tex2DVec4Write(dst, x, y, to_float4(0.0f, 0.0f, 0.0f, 0.0f));
    }
}
]]

-- Mask expansion kernel (dilate operation)
FSSCL_ExpandMaskSource = [[
__KERNEL__ void FSSCL_ExpandMaskKernel(__CONSTANTREF__ FSSCL_Params *params,
    __TEXTURE2D__ mask, __TEXTURE2D__ original, __TEXTURE2D_WRITE__ dst)
{
    DEFINE_KERNEL_ITERATORS_XY(x, y)
    
    // Boundary check
    if (x >= params->srcsize[0] || y >= params->srcsize[1]) return;
    
    float4 maskPixel = _tex2DVec4(mask, x, y);
    
    // If already in mask, keep it
    if (maskPixel.w > 0.001f) {
        _tex2DVec4Write(dst, x, y, maskPixel);
        return;
    }
    
    // Search for nearby mask pixels within radius
    int r = params->expandRadius;
    for (int dy = -r; dy <= r; dy++) {
        for (int dx = -r; dx <= r; dx++) {
            if (dx == 0 && dy == 0) continue;
            
            int nx = x + dx;
            int ny = y + dy;
            
            // Boundary check for neighbor
            if (nx < 0 || nx >= params->srcsize[0] || 
                ny < 0 || ny >= params->srcsize[1]) continue;
            
            float4 neighbor = _tex2DVec4(mask, nx, ny);
            
            // If neighbor is in mask, include this pixel from original image
            if (neighbor.w > 0.001f) {
                _tex2DVec4Write(dst, x, y, _tex2DVec4(original, x, y));
                return;
            }
        }
    }
    
    // No nearby mask pixels found, make transparent
    _tex2DVec4Write(dst, x, y, to_float4(0.0f, 0.0f, 0.0f, 0.0f));
}
]]

-- Helper function to create color input triplet
function AddColorInput(self, index)
    local groupID = index
    
    -- Color Group
    self:BeginControlNest("Color" .. index , "FSSCL_Color" .. index, true, {})

    -- Checkbox to enable/disable this color
    self:AddInput("ON", "Color" .. index .. "ON", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0,
        ICD_Width = 0.25,
    })
    
    -- RGB color picker
    self:AddInput("Color " .. index, "Color" .. index, {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.0,
        IC_ControlGroup = groupID,
        IC_ControlID = 0,
    })
    
    self:AddInput("Color " .. index .. " G", "Color" .. index .. "G", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.0,
        IC_ControlGroup = groupID,
        IC_ControlID = 1,
    })
    
    self:AddInput("Color " .. index .. " B", "Color" .. index .. "B", {
        LINKID_DataType = "Number",
        INPID_InputControl = "ColorControl",
        INP_Default = 0.0,
        IC_ControlGroup = groupID,
        IC_ControlID = 2,
    })

    self:EndControlNest()
end

-- Create UI controls
function Create()
    -- Main input image
    InImage = self:AddInput("Input", "Input", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })

    -- Color matching tolerance (Euclidean distance)
    InTolerance = self:AddInput("Tolerance", "Tolerance", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0.05,
        INP_MinScale = 0.0,
        INP_MaxScale = 1.0,
    })
    
    -- Expansion radius for dilate operation
    InExpandRange = self:AddInput("Expand Range", "ExpandRange", {
        LINKID_DataType = "Number",
        INPID_InputControl = "SliderControl",
        INP_Default = 0,
        INP_Integer = true,
        INP_MinScale = 0,
        INP_MaxScale = 50,
        INP_MinAllowed = 0,
        INP_MaxAllowed = 100,
    })

    -- Invert mask
    InInvert = self:AddInput("Invert", "Invert", {
        LINKID_DataType = "Number",
        INPID_InputControl = "CheckboxControl",
        INP_Integer = true,
        INP_Default = 0,
        ICD_Width = 1.0,
    })

    -- Add 8 color inputs
    for i = 1, 8 do
        AddColorInput(self, i)
    end
    
    -- Output image
    OutImage = self:AddOutput("Output", "Output", {
        LINKID_DataType = "Image",
        LINK_Main = 1,
    })
end

-- Collect enabled colors from UI
function CollectColors(self, req)
    local colors = {}
    local numColors = 0
    
    for i = 1, 8 do
        local onInput = self:FindInput("Color" .. i .. "ON")
        if onInput and onInput:GetValue(req).Value == 1 then
            local rInput = self:FindInput("Color" .. i)
            local gInput = self:FindInput("Color" .. i .. "G")
            local bInput = self:FindInput("Color" .. i .. "B")
            
            if rInput and gInput and bInput then
                numColors = numColors + 1
                colors[numColors] = {
                    rInput:GetValue(req).Value,
                    gInput:GetValue(req).Value,
                    bInput:GetValue(req).Value
                }
            end
        end
    end
    
    return colors, numColors
end

-- Main processing function
function Process(req)
    -- Get input values
    local img = InImage:GetValue(req)
    local tolerance = InTolerance:GetValue(req).Value
    local expandRange = InExpandRange:GetValue(req).Value
    local invert = InInvert:GetValue(req).Value

    -- Early exit if no input image
    if not img then
        OutImage:Set(req, nil)
        return
    end

    -- Collect enabled target colors
    local colors, numColors = CollectColors(self, req)
    
    -- Early exit if no colors selected
    if numColors == 0 then
        OutImage:Set(req, img)
        return
    end
    
    local width = img.Width
    local height = img.Height
    
    -- === Generate initial mask ===
    local masked = Image({IMG_Like = img, IMG_DeferAlloc = false})
    local maskNode = DVIPComputeNode(req, "FSSCL_MaskGeneratorKernel", FSSCL_MaskGeneratorSource, 
                                     "FSSCL_Params", FSSCL_Params)
    
    if not maskNode then
        print("SelectColor: Failed to create mask generator node")
        OutImage:Set(req, img)
        return
    end
    
    -- Set parameters for mask generation
    local params = maskNode:GetParamBlock(FSSCL_Params)
    params.numColors = numColors
    params.tolerance = tolerance
    params.srcsize[0] = width
    params.srcsize[1] = height
    params.invert = invert
    
    -- Copy target colors to GPU buffer
    for i = 0, numColors - 1 do
        params.targetColors[i][0] = colors[i+1][1]
        params.targetColors[i][1] = colors[i+1][2]
        params.targetColors[i][2] = colors[i+1][3]
    end
    
    maskNode:SetParamBlock(params)
    maskNode:AddSampler("RowSampler", TEX_FILTER_MODE_POINT, 
                       TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_FALSE)
    maskNode:AddInput("src", img)
    maskNode:AddOutput("dst", masked)
    
    if not maskNode:RunSession(req) then
        print("SelectColor: Mask generation failed")
        OutImage:Set(req, img)
        return
    end
    
    -- === Expand mask if radius > 0 ===
    if expandRange > 0 then
        local expanded = Image({IMG_Like = img, IMG_DeferAlloc = false})
        local expandNode = DVIPComputeNode(req, "FSSCL_ExpandMaskKernel", FSSCL_ExpandMaskSource, 
                                          "FSSCL_Params", FSSCL_Params)
        
        if not expandNode then
            print("SelectColor: Failed to create expand node")
            OutImage:Set(req, masked)
            return
        end
        
        -- Set parameters for expansion
        local params2 = expandNode:GetParamBlock(FSSCL_Params)
        params2.expandRadius = expandRange
        params2.numColors = numColors
        params2.tolerance = tolerance
        params2.srcsize[0] = width
        params2.srcsize[1] = height
        params2.invert = invert
        
        -- Copy target colors (needed for expand kernel)
        for i = 0, numColors - 1 do
            params2.targetColors[i][0] = colors[i+1][1]
            params2.targetColors[i][1] = colors[i+1][2]
            params2.targetColors[i][2] = colors[i+1][3]
        end
        
        expandNode:SetParamBlock(params2)
        expandNode:AddSampler("RowSampler", TEX_FILTER_MODE_POINT, 
                            TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_FALSE)
        expandNode:AddInput("mask", masked)
        expandNode:AddInput("original", img)
        expandNode:AddOutput("dst", expanded)
        
        if expandNode:RunSession(req) then
            OutImage:Set(req, expanded)
            return
        else
            print("SelectColor: Mask expansion failed")
        end
    end
    
    -- Output the masked image
    OutImage:Set(req, masked)
end